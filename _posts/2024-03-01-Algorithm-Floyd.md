---
title: Floyd(플로이드) - 최단거리
date: 2024-03-01 +09:00
categories:
  - Study
  - Algorithm
tags:
  - 알고리즘
  - 플로이드
---
## Floyd(플로이드)란?

플로이드 알고리즘은 최단 경로를 찾는 알고리즘 중 하나임

이 알고리즘을 사용할 때는 주의할 특징들이 있음
- 방향그래프이건 무방향 그래프이건 상관이 없음
- 간선의 값이 음수여도 되지만 음수인 사이클이 있으면 안됨
	- (사실 이경우는 잘없음)

## Floyd vs Dijkstra

두 알고리즘 모두 최단 경로를 찾는 것은 동일함    
하지만 아래와 같은 차이가 있음
- 간선이 음수여도 되는가
	- 플로이드 - 음수여도 되지만 사이클이 있으면 안됨
	- 다익스트라 - 음수이면 안됨
- 어떤 최단거리를 구하는가
	- 플로이드 - 모든 정점 사이의 최단거리를 구함
	- 다익스트라 - 한 정점에서 다른 정점들과의 최단거리를 구함
	- (기능은 플로이드가 좋은데 효율성은 다익스트라가 더 좋음)


## 구현

이 알고리즘의 경우 예시를 통해 이해하면 좀 더 쉬움   
아래의 예시는 모두 \[바킹독\]님의 유튜브 강의에서 따온 것임을 알림    
<del>(그는 신이야)</del>

우선 아래와 같은 경우가 있을 각 정점간의 최단거리를 구하려고 함   

<b> 1. 우선 채울 수 있는 모든 최단거리를 채움 (s->s 는 당연히 0)</b>

![](images/2024-03-01-Algorithm-Floyd.png)

그럼 위와같이 테이블이 채워질 것임   
만약 방향성 그래프라면 어떻게 채워질까?    
1->3 의 경우 dt\[1\]\[3\] ,dt\[3\]\[1\] 가 모두 채워지는 것이 아닌 dt\[1\]\[3\]만 채워짐   
(알고리즘의 동작 방식은 동일함)

<b>2. 노드 1 을 거쳐서 갈 수 있는 경로를 비교하여 업데이트함</b>

![](images/2024-03-01-Algorithm-Floyd-1.png)

예를 들어 2->3 일 때 2->1->3으로 가면 더 빨리 갈 수 있음   
즉, <b>dt[2][3] > dt[2][1] + dt[1][3] </b>이기에 최단거리 테이블이 업데이트됨   
이렇게 1행부터 5행까지 모두 체크한 후 최단거리를 업데이트 해줌   

그럼 해당 최단거리 테이블은 1번 노드를 거쳐서 갈 때의 최단거리 테이블이 됨

<b>3. 노드 2를 거쳐서 갈 수 있는 경로를 비교하여 업데이트 함</b>

![](images/2024-03-01-Algorithm-Floyd-2.png)

2번 순서와 같이 최단거리 테이블을 업데이트 해줌

그럼 해당 최단 거리 테이블은 1, 2번 노드를 거쳐서 갈 때의 최단거리 테이블이 됨

<b>4. 위의 과정을 5행까지 모두 해줌</b>

![](images/2024-03-01-Algorithm-Floyd-3.png)

그러면 위의 그림과 같이 최단 거리 테이블을 완성할 수 있음

## Floyd 알고리즘의 시간복잡도

예를 들어 정점이 V개라고 할 때

- 총 <b>V단계</b>에 걸쳐 최단거리 테이블이 업데이트 됨 
- 각 단계마다 총 <b>V<sup>2</sup>개의 모든 dt[s][t]와 dt[s][k] + dt[k][t]를 비교해야함</b>

따라서 <b>V<sup>3</sup></b>이 됨

<b>그럼 정점이 1000개면 시간복잡도가 10억이니 쓸 수 없는 거 아닌가?</b>   
- 하지만 플로이드 알고리즘은 주로 사칙연산이 대부분이라 1000개까진 쓸만함

여기서 더 줄이고 싶으면 어캄??
- 코드를 짤 때 min을 이용하지 말고 if문을 사용하면 더 빠름
- 그 이유는 대입보다 연산이 더 빠르기 때문 min은 같은 값을 대입하는 경우도 있기 때문임


## BOJ - 11404 코드

INF 를 0x3f3f3f3f로 한 이유는 overflow를 예방하기 위함

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
int a, b, c;
int INF = 0x3f3f3f3f;
int arr[101][101];

int main(){
    cin >> n >> m;

    for(int i=1; i<=n; i++){
        fill(arr[i], arr[i]+1+n, INF);
        arr[i][i] = 0;
    }

    for(int i=0; i<m; i++){
        cin >> a >> b >> c;
        arr[a][b] = min(arr[a][b], c);
    }

    for(int i=1; i<=n; i++){
        for(int j=1; j<=n; j++){
            for(int k=1; k<=n; k++){
                arr[j][k] = min(arr[j][k], arr[j][i] + arr[i][k]);
            }
        }
    }

    for(int i=1; i<=n; i++){
        for(int j=1; j<=n; j++){
            if(arr[i][j] == INF) cout << 0 << " ";
            else cout << arr[i][j] << " ";
        }
        cout << "\n";
    }

    return 0;
}

```