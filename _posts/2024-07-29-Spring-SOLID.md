---
title: "[Spring] SOLID"
date: 2024-07-29 +09:00
categories:
  - Study
  - Spring
tags:
  - 스프링
  - 스프링부트
---
>김영한님의 Spring 강의를 정리한 글임을 알립니다.

## SOLID
---
클린코드의 저자 로버트 마틴이 객체 지향 설계의 5가지 원칙을 정리한 것이다.

- SRP: 단일 책임 원칙(single responsibility principle)
- OCP: 개방-폐쇄 원칙 (Open/closed principle)
- LSP: 리스코프 치환 원칙 (Liskov substitution principle)
- ISP: 인터페이스 분리 원칙 (Interface segregation principle)
- DIP: 의존관계 역전 원칙 (Dependency inversion principle)

이 중 OCP와 DIP가 가장 중요하다.

## SRP
---
**단일 책임 원칙 - 한 클래스는 하나의 책임만 가져야 한다.**

사실 하나의 책임이라는 것이 모호하다.   
큰 책임이 있고 작은 책임이 있을 수 있다. 또한, 문맥과 상황에 따라 다르다.

중요한 기준은 변경이라고 보면 된다. 변경이 일어날 때, 파급효과가 적으면 잘 따른 것이다.

## OCP
---
**개방 폐쇄 원칙 - 확장에는 열려 있으나 변경에는 닫혀 있어야한다.**

**다형성을 활용**하는 것이다.

**인터페이스를 구현한 새로운 클래스**를 만들어서 새로운 기능을 구현하면 된다.    
(기존의 코드가 바뀌지 않는다.)

아래의 경우 MemberRepository의 종류를 바꾸기 위해 **MemberService 코드의 변화가 일어난다.**

![](images/2024-07-26-Spring-SOLID-1.png)

MemberRepository의 구현체를 변경하기 위해서 클라이언트(Service)의 코드를 변경해야한다.

**다형성을 사용하긴 했지만 OCP 원칙을 지키지 못한 것이다.**

따라서, 객체를 생성하고 연관관계를 맺어주는 설정자가 필요하다.   
-> 이러한걸 Spring이 해주는 것이다.

## LSP
---
**리스코프 치환 원칙 - 객체는 프로그램의 정확성을 깨지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.**

다형성에서 하위 클래스는 **인터페이스 규약을 지켜야한다**는 것이다. 컴파일 수준을 넘어서는 말이다.   
(그래야 하위 클래스를 사용할 때도 안심하고 사용할 수 있다.)

예를 들어, 자동차의 엑셀은 앞으로 가라는 기능이다. 이 기능을 뒤로가게 구현해서는 안된다.

## ISP
---
**인터페이스 분리 원칙 - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 한보다 낫다.**

- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
 
분리하면 정비 인터페이스 자체가 변해도 운전자 **클라이언트에 영향을 주지 않는다.**   

이렇게 하면, **인터페이스가 명확해지고, 대체 가능성이 높아진다.**    
-> 덩어리가 크면 다 구현하기 힘들다.

## DIP
---
**의존관계 역전 원칙 - 추상화에 의존해야지, 구체화에 의존해서는 안된다.**

의존성 주입이 이 원칙을 따르는 방법 중 하나다.

구현 클래스에 의존하지 말고 인터페이스에 의존하라는 뜻이다.
(역할에 의존하게 해야하는 것과 같다.)

MemberService가 MemoryMemberRepository에 의존해서는 안된다.   
**MemberRepository 인터페이스만 의존**하여 MemberService를 만들어야한다.

그래야 변경에 유연하게 대처가 가능하다.

## 정리
---
객체 지향의 핵심은 다형성이다.

하지만, 다형성 만으로는 OCP, DIP를 지킬 수 없다. (클라이언트 코드도 변경된다.)

따라서, 우리는 Spring Framework를 사용해 다형성 + OCP, DIP를 가능하게 한다.
- DI(Dependency Injection) : 의존관계 주입, 의존성 주입
- DI 컨테이너 제공 : 객체들을 컨테이너에 넣어두고 의존관계를 연결, 주입해줌

즉, 클라이언트 코드의 변경 없이 기능을 확장할 수 있다.