---
title: "[Linux] 2. 레코드 잠금"
date: 2023-09-13 +09:00
categories:
  - School
  - Linux
tags:
  - Linux
---
해당 글은 학부 공부를 목적으로 한 글임
정리가 되어있지 않고 정보를 나열한 형태임
정확하지 않은 정보가 있을 수 있음

## 레코드 잠금이 필요한 이유
* 레코드 잠금과 파일잠금의 차이점
  * 레코드 잠금은 파일의 일부분(레코드)만 잠근다는 것이 다름
  * 레코드 잠금을 하면 나머지 부분은 다른 프로세스가 접근 가능하여 효율적임
* 레코드 잠금 하는법
  * fcntl()함수로 사용 가능
  * int fcntl(int fd, int cmd, struct flock *lock)
  * 성공하면 0, 실패하면 -1

## 읽기잠금과 쓰기잠금
* 읽기잠금 : 여러 프로세스가 공유 가능한 읽기 잠금
  * F_RDLCK 
* 쓰기잠금 : 한 프로세스만 가질 수 있는 배타적인 쓰기 잠금
  * F_WRLCK
* 잠금 규칙에는 뭐가 있는가? (파일잠금과 동일)
  1. 아무 잠금도 없는 경우 아무 잠금이나 승인됨
  2. 읽기잠금이 걸려있는 경우 읽기잠금을 요청하면 승인되지만 쓰기잠금을 요청하면 거절됨   
	(쉽게 생각하면 누가 읽고 있는데 쓸려고 하면 문제가 생기니까 거절되는 것임)
  1. 쓰기잠금이 걸려있는 경우 어떤한 경우든 거절됨   
    (누가 쓰고 있는데 읽으려 한다거나 쓰려하면 거절되는 것)

## fcntl() 함수
```c
int fcntl(int fd, int cmd, struct flock *lock)
        
cmd
* F_GETLK : 잠금 검사
* F_SETLK : 잠금 설정 혹은 해제
* F_SETLKW : 잠금 설정(블로킹 버전) 혹은 해제

struct flock{
    short l_type;   //잠금 종류
    off_t l_start;  //잠금 시작 위치
    short l_whence; //기준 위치
    off_t l_len;    //잠금 길이 : 바이트 수
    pid_t l_pid;    //프로세스 번호
}

//예시 : lock 구조체 안에 설정된 위치를 F_SETLKW(잠금 설정 또는 해제)
//lock 의 l_type에 의해 읽기잠금 또는 쓰기잠금(F_WR 선택
if(fcntl(fd, F_SETLKW, &lock) == -1){
    perror(argv[1]);
    exit(3);
}
```

## 잠금 함수 lockf()
좀 더 쉽게 잠금 요철을 하기 위한 함수
* fcntl과의 차이점
  * 배타적 쓰기를 위한 잠금만 제공함
  * 그 이외에는 동일(레코드에 대해 잠금)
* lockf() 사용법
  * int lockf(int fd, int cmd, off_t len)을 통해 사용
* cmd 종류
  * F_LOCK : 지정된 영역에 대해 쓰기잠금, 이미 잠금이면 해제 될 때까지 대기
  * F_TLOCK : 지정된 영역에 대해 쓰기잠금, 이미 잠금이면 기다리지 않고 -1 반환 (Time)
  * F_TEST : 이미 잠겨있는지 체크, 잠금 X면 0 반환 잠금 O면 -1 반환
  * F_ULOCK : 지정된 영역의 잠금을 해제
* len이 의미하는 바
  * 레코드의 크기